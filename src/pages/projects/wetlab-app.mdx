---
title: 'Wetlab Assistant'
description: 'Making Physics calculations 10 times quicker'
githubLink: 'https://github.com/Svaught598/WetLabApp'
imageLink: '/images/wetlab.png'

layout: 'ProjectLayout'
---
Other than writing small scripts to perform very specific tasks, this was my first real programming project. I had some difficulties finding applications to make solutions for my research (most applications do not perform the calculations that I needed), so I decided to make my own. I would commonly spend 30-40 minutes just doing calculations, then more time doing them again just to ensure that they were correct. It was during this project that I realized that I truly loved software development.

## Problems
So the biggest problem I had starting out is a problem I wouldn’t even dream of having today. I couldn’t figure out how to organize packages and functions to make the code modular. I spent about a month messing around with a broken pile of conditionals and magic values, and eventually gave up. The project wasn’t even functional, and my database was a crappy JSON file. Did I mention that I didn’t even know what a class was?

Some time passed, and I stumbled upon the idea of architecture in code. For as long as I pursued this project, I hadn’t looked into reading about programming practices at all, so the fact that there are agreed upon codebase structures really shocked me. I read more about Object-Oriented Programming, and became familiar with some of the software design patterns commonly used. I quickly decided to refactor the entire codebase using an MVC architecture. After some time, adding features became super easy! The project went from being painfully unmaintainable to functional and even organized. I’m sure there are a lot of areas that could be designed better, but just making the change to modular code made such a huge difference that I’m not even sure what those areas might be.

The only other major challenge was handling dependencies. I used Python and the Kivy framework to build this project, but switched dev machines halfway through. This resulted in a new installation of Kivy that was different from the prior one. I had no idea at the time, and never implemented unit tests, so I didn’t catch the issue until I had already built on top of the new API. I ended up with an application that was built with two incompatible versions of Kivy, that was able to be run on **zero** platforms. I fixed it. *eventually*. Needless to say, I understand the value of unit testing and dependency management now.