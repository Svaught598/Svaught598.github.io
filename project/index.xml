<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects | Steven Vaught</title>
    <link>/project/</link>
      <atom:link href="/project/index.xml" rel="self" type="application/rss+xml" />
    <description>Projects</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 31 Jul 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Projects</title>
      <link>/project/</link>
    </image>
    
    <item>
      <title>CHIP-8 Emulator</title>
      <link>/project/chip8/</link>
      <pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate>
      <guid>/project/chip8/</guid>
      <description>&lt;h1 id=&#34;about-the-project&#34;&gt;About The Project&lt;/h1&gt;
&lt;p&gt;Since I found out about system emulation, I have been super fascinated with it. I&amp;rsquo;m building this CHIP-8 emulator (interpreter&amp;hellip;?) to get started since the EmuDev community tends to suggest it for first-timers. So what is the CHIP-8? The CHIP-8 is an abstract machine (not unlike the JVM) that was first used to play games on the COSMAC VIP in the 1970s. I thought while considering this project, &amp;ldquo;Why not implement an abstract virtual machine by using the implementation of a different abstract virtual machine?&amp;rdquo;, and thus, this project came to be!&lt;/p&gt;
&lt;h1 id=&#34;features&#34;&gt;Features&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Thorough Debug UI (panels to monitor registers, stack, timers, program counter, etc&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Save/Load from savestates&lt;/li&gt;
&lt;li&gt;Variable CPU clock speed&lt;/li&gt;
&lt;li&gt;Pause/Resume/Reset Emulation&lt;/li&gt;
&lt;li&gt;Load ROMs from file or from list&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;problems&#34;&gt;Problems&lt;/h1&gt;
&lt;p&gt;I haven&amp;rsquo;t used Java extensively, and this project hardly made me an expert, but I have become much more familiar with the language as a result. There were some pretty complex parts to making this emulator, the most challenging of which had to do with the Event dispatch thread and the opcode 0xFX0A. Anyone familiar enough with the CHIP-8 to recognize opcodes might see where this is going: any time the CPU interpreted 0xFX0A, it paused the thread, which meant that input couldn&amp;rsquo;t be read.&lt;/p&gt;
&lt;p&gt;Opcode 0xFX0A is pretty simple. At least, my implementation is. It tells the CPU &amp;ldquo;hey, why don&amp;rsquo;t you &lt;code&gt;sleep()&lt;/code&gt; until a key is pressed?&amp;rdquo;. This becomes a problem in a single threaded application since continuous calls of &lt;code&gt;sleep()&lt;/code&gt; end up blocking IO, so the program is never able to &lt;em&gt;tell&lt;/em&gt; when a key is pressed. So in plainspeak, an infitite loop. I ended up fixing the issue by dispatching UI/IO events on the &lt;code&gt;Event Dispatch Thread&lt;/code&gt; provided by swing, while running other logic on a separate thread. This was a pretty nice solution, but I do wish I would&amp;rsquo;ve spent more time planning the implementation before jumping right into the code. This brings us to the biggest thing I learned:&lt;/p&gt;
&lt;h1 id=&#34;the-importance-of-planning&#34;&gt;The Importance of Planning&lt;/h1&gt;
&lt;p&gt;As a Physics graduate (now aspiring developer) I haven&amp;rsquo;t had the proper training in computer science fundamentals and best practices for Object-Oriented Programming (OOP). This isn&amp;rsquo;t to say I suck (I mean, I could be better), but that I didn&amp;rsquo;t even know what to consider while building this application. This lack of planning - in a Java project, mind you - resulted in a mess of everything being public. This wasn&amp;rsquo;t a huge issue for this small project, but in a larger project it could manifest as having pieces of code that are insanely complex.&lt;/p&gt;
&lt;p&gt;For example, say there is a method in CPU called &lt;code&gt;initializeMemory()&lt;/code&gt; that does the heavy lifting of setting the memory, register, timers, etc&amp;hellip; all to 0. Now we make the method public and call it from the CPU constructor upon startup AND call it from the GUI panel anytime someone presses &lt;strong&gt;reset&lt;/strong&gt;. Seems like a win-win. Some time passes, and it is decided that the current implementation of &lt;strong&gt;reset&lt;/strong&gt; is not what is needed; the application actually needs to preserve some memory upon resetting the system! now there are two options, neither of which are super enticing:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Expose a &lt;strong&gt;new&lt;/strong&gt; method in CPU called &lt;code&gt;reset()&lt;/code&gt;. If the CPU and GUI panel are the only objects using &lt;code&gt;initializeMemory()&lt;/code&gt;, great! That means this was caught early, and the code isn&amp;rsquo;t all tangly and gross. But imagine every single one of your test cases calls &lt;code&gt;initializeMemory()&lt;/code&gt;. We can&amp;rsquo;t just make the old method private, or we can&amp;rsquo;t run the tests! Now there are two public methods that are confusingly similar. This branches into a subdecision of &lt;strong&gt;refactoring tests&lt;/strong&gt; or &lt;strong&gt;deal with ambiguity&lt;/strong&gt;. The former makes the code maintainable but takes a lot longer and the second is a quick fix that makes additional changes more complex, but a little bit of planning would have circumvented this entire fiasco. Needless to say, I have become acquainted with the concept of technical debt. Oh yeah, and option two&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I lied, sorry. The two options are really just one option in a trenchcoat that will either mug you or make you balance their checkbook. Just do things right and plan next time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Infection Simulation</title>
      <link>/project/infection/</link>
      <pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate>
      <guid>/project/infection/</guid>
      <description>&lt;h1 id=&#34;about-the-project&#34;&gt;About The Project&lt;/h1&gt;
&lt;p&gt;This was one of the projects I did during my Computational Physics course at Texas A&amp;amp;M University-Commerce. The programming and physics were a ton of fun! &amp;hellip;learning the syntax for gnuplot wasn&amp;rsquo;t. Here&amp;rsquo;s a quick example for the terribly unintuitive syntax (and yes, the repeated colons are necessary):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plot infile using 2:xtic(1) every :::1::1 t &amp;quot;Healthy&amp;quot; lc rgb &amp;quot;blue&amp;quot;, \
         &#39;&#39; using 3 every :::1::1 t &amp;quot;Infected&amp;quot; lc rgb &amp;quot;dark-green&amp;quot;, \
         &#39;&#39; using 4 every :::1::1 t &amp;quot;Recovered&amp;quot; lc rgb &amp;quot;dark-yellow&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;effectiveness-of-social-distancing&#34;&gt;Effectiveness of Social Distancing&lt;/h1&gt;
&lt;p&gt;I incorporated a parameter to set a certain amount of the population to stay still to kind of simulate &lt;em&gt;social distancing&lt;/em&gt;. The idea was that we should be able to get an idea for how effective social distancing is when it comes to slowing the spread of a contagion. It turns out it is pretty effective! I don&amp;rsquo;t have the results in the Github link, but I believe it came out to be that 30% of the population was social distancing, the rate of infection was halved.&lt;/p&gt;
&lt;h1 id=&#34;problems&#34;&gt;Problems&lt;/h1&gt;
&lt;p&gt;Honestly, the bulk of the problems I had with this project revolved around using this plotting software. The learning curve is comparable to the base of a cliff; it was impossibly complex at first and all at once became straightforward and simple. I actually prefer gnuplot over the more popular matplotlib after this project since the software is so flexible with plotting data. If there are any academics reading this, I implore you: learn how to use this software. It made a lot of things - normally complex in Python/Matplotlib - very simple.&lt;/p&gt;
&lt;p&gt;I did have one minor problem unrelated to Gnuplot: 10 seconds of simulation took 10 minutes to prepare. This really wasn&amp;rsquo;t a huge issue, but I liked having instant feeback when I made changes to the project, so I took a profiler to my code and found that the biggest bottleneck was with IO. Apparently opening and closing files takes a lot of time. News to me. I circumvented this by storing all the data in one file, using &lt;code&gt;\n&lt;/code&gt; as a delimeter to differentiate between clusters of particles at different timesteps, but alas, the program still took 8 minutes to prepare 10 seconds!&lt;/p&gt;
&lt;p&gt;The profiler now said that the bottleneck was invoking a subprocess with gnuplot. I realized that plotting any constiuent timestep was an orthogonal task to all others. This meant that I could call all &lt;code&gt;plot(timestep)&lt;/code&gt; in parallel with each other and not worry about complicated stuff like race conditions. Implementing it was super easy, but it also meant that I had to start storing data for timesteps in separate files to keep things thread safe (probably didn&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to, but I didn&amp;rsquo;t know gnuplot well enough to come up with a better solution). It also meant that each plotting task would require it&amp;rsquo;s own instance of Gnuplot, so there was a very real chance it would remain slow, or worse: &lt;em&gt;become even slower&lt;/em&gt;. I made the changes, and got a speed increase of X10! Now, rendering 10 seconds of simulation was just short of a minute!&lt;/p&gt;
&lt;h1 id=&#34;future-work&#34;&gt;Future Work&lt;/h1&gt;
&lt;p&gt;I might pick this project up again in the future since there is so much room for expansion. Things could be made much quicker by using CUDA and drawing with OpenGL instead of plotting.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WetLabApp</title>
      <link>/project/wetlab/</link>
      <pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/project/wetlab/</guid>
      <description>&lt;h1 id=&#34;about-the-project&#34;&gt;About The Project&lt;/h1&gt;
&lt;p&gt;Other than writing small scripts to perform very specific tasks, this was my first real programming project. I had some difficulties finding applications to make solutions for my research (most applications do not perform the calculations that I needed), so I decided to make my own. I would commonly spend 30-40 minutes just doing calculations, then more time doing them again just to ensure that they were correct. It was during this project that I realized that I truly loved software development.&lt;/p&gt;
&lt;h1 id=&#34;problems&#34;&gt;Problems&lt;/h1&gt;
&lt;p&gt;So the biggest problem I had starting out is a problem I wouldn&amp;rsquo;t even dream of having today. I couldn&amp;rsquo;t figure out how to organize packages and functions to make the code &lt;code&gt;modular&lt;/code&gt;. I spent about a month messing around with a broken pile of conditionals and magic values, and eventually gave up. The project wasn&amp;rsquo;t even functional, and my database was a crappy JSON file. Did I mention that I didn&amp;rsquo;t even know what a class was? I thought, &lt;em&gt;&amp;ldquo;Maybe this whole software thing isn&amp;rsquo;t right for me&amp;rdquo;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Some time passed, and I stumbled upon the idea of architecture in code. For as long as I pursued this project, I hadn&amp;rsquo;t looked into reading about programming practices at all, so the fact that there are agreed upon codebase structures really shocked me. I read more about Object-Oriented Programming, and became familiar with some of the software design patterns commonly used. I quickly decided to refactor the entire codebase using an MVC architecture. After some time, adding features became super easy! The project went from being painfully unmaintainable to functional and even organized. I&amp;rsquo;m sure there are a lot of areas that could be designed better, but just making the change to modular code made such a huge difference that I&amp;rsquo;m not even sure what those areas might be.&lt;/p&gt;
&lt;p&gt;The only other major challenge was handling dependencies. I used Python and the Kivy framework to build this project, but switched dev machines halfway through. This resulted in a new installation of Kivy that was different from the prior one. I had no idea at the time, and never implemented unit tests, so I didn&amp;rsquo;t catch the issue until I had already built on top of the new API. I ended up with an application that was built with two incompatible versions of Kivy, that was able to be run on &lt;strong&gt;zero&lt;/strong&gt; platforms. I fixed it &lt;em&gt;eventually&lt;/em&gt;. Needless to say, I understood the value of unit testing and dependency management after this absolute fiasco.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
